"""
Automated vulnerability scanner for FisioRAG security assessment.
Comprehensive security testing and compliance validation.
"""

import asyncio
import json
import logging
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
import aiohttp
import yaml


@dataclass
class Vulnerability:
    """Security vulnerability record."""
    id: str
    severity: str  # critical, high, medium, low
    category: str
    title: str
    description: str
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    cve_id: Optional[str] = None
    remediation: Optional[str] = None
    references: List[str] = None
    
    def __post_init__(self):
        if self.references is None:
            self.references = []


@dataclass
class ScanResult:
    """Vulnerability scan results."""
    scan_id: str
    timestamp: datetime
    duration_seconds: float
    scanner: str
    target: str
    vulnerabilities: List[Vulnerability]
    summary: Dict[str, int]
    compliance_status: Dict[str, bool]
    recommendations: List[str]


class VulnerabilityScanner:
    """
    Comprehensive vulnerability scanner for FisioRAG.
    Integrates multiple security scanning tools and techniques.
    """
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.scan_results: List[ScanResult] = []
        
        # Scanner configurations
        self.scanners = {
            "bandit": self._run_bandit_scan,
            "safety": self._run_safety_scan,
            "semgrep": self._run_semgrep_scan,
            "docker": self._run_docker_scan,
            "dependency": self._run_dependency_scan,
            "api": self._run_api_security_scan,
            "configuration": self._run_config_scan
        }
    
    async def run_comprehensive_scan(self) -> ScanResult:
        """Run comprehensive security scan across all components."""
        scan_id = f"fisiorag_security_scan_{int(time.time())}"
        start_time = time.time()
        
        self.logger.info(f"Starting comprehensive security scan: {scan_id}")
        
        all_vulnerabilities = []
        compliance_status = {}
        recommendations = []
        
        # Run all scanners in parallel for efficiency
        scan_tasks = []
        for scanner_name, scanner_func in self.scanners.items():
            task = asyncio.create_task(self._safe_scan(scanner_name, scanner_func))
            scan_tasks.append(task)
        
        # Gather results
        scanner_results = await asyncio.gather(*scan_tasks, return_exceptions=True)
        
        # Process results
        for i, result in enumerate(scanner_results):
            scanner_name = list(self.scanners.keys())[i]
            
            if isinstance(result, Exception):
                self.logger.error(f"Scanner {scanner_name} failed: {result}")
                continue
            
            if result:
                vulnerabilities, compliance, recs = result
                all_vulnerabilities.extend(vulnerabilities)
                compliance_status.update(compliance)
                recommendations.extend(recs)
        
        # Generate summary
        summary = self._generate_summary(all_vulnerabilities)
        
        # Create scan result
        scan_result = ScanResult(
            scan_id=scan_id,
            timestamp=datetime.now(),
            duration_seconds=time.time() - start_time,
            scanner="comprehensive",
            target="fisiorag",
            vulnerabilities=all_vulnerabilities,
            summary=summary,
            compliance_status=compliance_status,
            recommendations=list(set(recommendations))  # Remove duplicates
        )
        
        self.scan_results.append(scan_result)
        
        self.logger.info(f"Scan completed: {len(all_vulnerabilities)} vulnerabilities found")
        return scan_result
    
    async def _safe_scan(self, scanner_name: str, scanner_func) -> Optional[Tuple]:
        """Safely execute scanner with error handling."""
        try:
            return await scanner_func()
        except Exception as e:
            self.logger.error(f"Scanner {scanner_name} error: {e}")
            return None
    
    async def _run_bandit_scan(self) -> Tuple[List[Vulnerability], Dict[str, bool], List[str]]:
        """Run Bandit security scanner for Python code."""
        vulnerabilities = []
        compliance = {"code_security": True}
        recommendations = []
        
        try:
            # Run Bandit scan
            result = subprocess.run([
                sys.executable, "-m", "bandit", 
                "-r", ".", 
                "-f", "json",
                "-x", "venv,node_modules,.git,htmlcov,load_testing/results"
            ], capture_output=True, text=True, cwd=".")
            
            if result.returncode == 0 or result.returncode == 1:  # 1 means issues found
                if result.stdout:
                    bandit_data = json.loads(result.stdout)
                    
                    for issue in bandit_data.get("results", []):
                        vulnerability = Vulnerability(
                            id=f"bandit_{issue.get('test_id', 'unknown')}",
                            severity=issue.get("issue_severity", "medium").lower(),
                            category="code_security",
                            title=issue.get("test_name", "Security Issue"),
                            description=issue.get("issue_text", ""),
                            file_path=issue.get("filename"),
                            line_number=issue.get("line_number"),
                            cve_id=None,
                            remediation=issue.get("more_info", ""),
                            references=[issue.get("more_info", "")] if issue.get("more_info") else []
                        )
                        vulnerabilities.append(vulnerability)
                
                # Check severity levels
                critical_high = [v for v in vulnerabilities if v.severity in ["critical", "high"]]
                if critical_high:
                    compliance["code_security"] = False
                    recommendations.append("Address critical/high severity code security issues")
                
        except Exception as e:
            self.logger.error(f"Bandit scan failed: {e}")
            recommendations.append("Install and configure Bandit for code security scanning")
        
        return vulnerabilities, compliance, recommendations
    
    async def _run_safety_scan(self) -> Tuple[List[Vulnerability], Dict[str, bool], List[str]]:
        """Run Safety scanner for known vulnerabilities in dependencies."""
        vulnerabilities = []
        compliance = {"dependency_security": True}
        recommendations = []
        
        try:
            # Run Safety scan
            result = subprocess.run([
                sys.executable, "-m", "safety", "check", "--json"
            ], capture_output=True, text=True)
            
            if result.stdout:
                safety_data = json.loads(result.stdout)
                
                for issue in safety_data:
                    vulnerability = Vulnerability(
                        id=f"safety_{issue.get('id', 'unknown')}",
                        severity="high",  # Safety issues are typically high
                        category="dependency",
                        title=f"Vulnerable dependency: {issue.get('package', 'unknown')}",
                        description=issue.get("advisory", ""),
                        file_path="requirements/dependencies",
                        cve_id=issue.get("cve"),
                        remediation=f"Update {issue.get('package')} to version {issue.get('safe_versions', 'latest')}",
                        references=[f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={issue.get('cve')}"] if issue.get('cve') else []
                    )
                    vulnerabilities.append(vulnerability)
                
                if vulnerabilities:
                    compliance["dependency_security"] = False
                    recommendations.append("Update vulnerable dependencies to secure versions")
        
        except Exception as e:
            self.logger.error(f"Safety scan failed: {e}")
            recommendations.append("Install Safety for dependency vulnerability scanning")
        
        return vulnerabilities, compliance, recommendations
    
    async def _run_semgrep_scan(self) -> Tuple[List[Vulnerability], Dict[str, bool], List[str]]:
        """Run Semgrep for advanced static analysis."""
        vulnerabilities = []
        compliance = {"static_analysis": True}
        recommendations = []
        
        try:
            # Check if semgrep is available
            result = subprocess.run(["semgrep", "--version"], capture_output=True)
            if result.returncode != 0:
                recommendations.append("Install Semgrep for advanced static analysis")
                return vulnerabilities, compliance, recommendations
            
            # Run Semgrep with security rules
            result = subprocess.run([
                "semgrep", "--config=auto", "--json", 
                "--exclude=venv", "--exclude=node_modules",
                "--exclude=.git", "--exclude=htmlcov"
            ], capture_output=True, text=True, cwd=".")
            
            if result.stdout:
                semgrep_data = json.loads(result.stdout)
                
                for finding in semgrep_data.get("results", []):
                    severity_map = {
                        "ERROR": "high",
                        "WARNING": "medium", 
                        "INFO": "low"
                    }
                    
                    vulnerability = Vulnerability(
                        id=f"semgrep_{finding.get('check_id', 'unknown')}",
                        severity=severity_map.get(finding.get("extra", {}).get("severity"), "medium"),
                        category="static_analysis",
                        title=finding.get("extra", {}).get("message", "Static analysis finding"),
                        description=finding.get("extra", {}).get("metadata", {}).get("description", ""),
                        file_path=finding.get("path"),
                        line_number=finding.get("start", {}).get("line"),
                        remediation=finding.get("extra", {}).get("fix", ""),
                        references=finding.get("extra", {}).get("references", [])
                    )
                    vulnerabilities.append(vulnerability)
                
                high_severity = [v for v in vulnerabilities if v.severity == "high"]
                if high_severity:
                    compliance["static_analysis"] = False
                    recommendations.append("Address high-severity static analysis findings")
        
        except Exception as e:
            self.logger.error(f"Semgrep scan failed: {e}")
        
        return vulnerabilities, compliance, recommendations
    
    async def _run_docker_scan(self) -> Tuple[List[Vulnerability], Dict[str, bool], List[str]]:
        """Scan Docker images for vulnerabilities."""
        vulnerabilities = []
        compliance = {"container_security": True}
        recommendations = []
        
        try:
            # Check if Docker is available
            docker_check = subprocess.run(["docker", "--version"], capture_output=True)
            if docker_check.returncode != 0:
                recommendations.append("Docker not available for container security scanning")
                return vulnerabilities, compliance, recommendations
            
            # Scan Docker image if exists
            image_name = "fisiorag:latest"
            
            # Try Trivy scanner if available
            trivy_result = subprocess.run([
                "trivy", "image", "--format", "json", image_name
            ], capture_output=True, text=True)
            
            if trivy_result.returncode == 0 and trivy_result.stdout:
                trivy_data = json.loads(trivy_result.stdout)
                
                for result in trivy_data.get("Results", []):
                    for vuln in result.get("Vulnerabilities", []):
                        vulnerability = Vulnerability(
                            id=f"docker_{vuln.get('VulnerabilityID')}",
                            severity=vuln.get("Severity", "medium").lower(),
                            category="container",
                            title=f"Container vulnerability: {vuln.get('PkgName')}",
                            description=vuln.get("Description", ""),
                            file_path=f"container/{vuln.get('PkgName')}",
                            cve_id=vuln.get("VulnerabilityID"),
                            remediation=f"Update {vuln.get('PkgName')} to {vuln.get('FixedVersion', 'latest')}",
                            references=vuln.get("References", [])
                        )
                        vulnerabilities.append(vulnerability)
                
                critical_vulns = [v for v in vulnerabilities if v.severity in ["critical", "high"]]
                if critical_vulns:
                    compliance["container_security"] = False
                    recommendations.append("Update container base image and dependencies")
            else:
                recommendations.append("Install Trivy for container vulnerability scanning")
        
        except Exception as e:
            self.logger.error(f"Docker scan failed: {e}")
        
        return vulnerabilities, compliance, recommendations
    
    async def _run_dependency_scan(self) -> Tuple[List[Vulnerability], Dict[str, bool], List[str]]:
        """Scan for outdated and vulnerable dependencies."""
        vulnerabilities = []
        compliance = {"dependency_management": True}
        recommendations = []
        
        try:
            # Check Python dependencies with pip-audit if available
            pip_audit_result = subprocess.run([
                sys.executable, "-m", "pip-audit", "--format=json"
            ], capture_output=True, text=True)
            
            if pip_audit_result.returncode == 0 and pip_audit_result.stdout:
                audit_data = json.loads(pip_audit_result.stdout)
                
                for package in audit_data:
                    for vuln in package.get("vulnerabilities", []):
                        vulnerability = Vulnerability(
                            id=f"pip_audit_{vuln.get('id')}",
                            severity="medium",
                            category="dependency",
                            title=f"Dependency vulnerability: {package.get('name')}",
                            description=vuln.get("description", ""),
                            file_path="requirements/dependencies",
                            cve_id=vuln.get("id"),
                            remediation=f"Update {package.get('name')} to secure version",
                            references=vuln.get("references", [])
                        )
                        vulnerabilities.append(vulnerability)
                
                if vulnerabilities:
                    compliance["dependency_management"] = False
                    recommendations.append("Update dependencies with known vulnerabilities")
        
        except Exception as e:
            self.logger.error(f"Dependency scan failed: {e}")
            recommendations.append("Install pip-audit for dependency vulnerability scanning")
        
        return vulnerabilities, compliance, recommendations
    
    async def _run_api_security_scan(self) -> Tuple[List[Vulnerability], Dict[str, bool], List[str]]:
        """Scan API endpoints for security vulnerabilities."""
        vulnerabilities = []
        compliance = {"api_security": True}
        recommendations = []
        
        # API security checks
        api_base = "http://localhost:8000"
        
        try:
            async with aiohttp.ClientSession() as session:
                # Check for security headers
                headers_result = await self._check_security_headers(session, api_base)
                vulnerabilities.extend(headers_result["vulnerabilities"])
                
                if headers_result["missing_headers"]:
                    compliance["api_security"] = False
                    recommendations.extend(headers_result["recommendations"])
                
                # Check for common API vulnerabilities
                api_vulns = await self._check_api_endpoints(session, api_base)
                vulnerabilities.extend(api_vulns)
        
        except Exception as e:
            self.logger.error(f"API security scan failed: {e}")
            recommendations.append("Ensure API is running for security assessment")
        
        return vulnerabilities, compliance, recommendations
    
    async def _check_security_headers(self, session: aiohttp.ClientSession, base_url: str) -> Dict[str, Any]:
        """Check for security headers in API responses."""
        vulnerabilities = []
        missing_headers = []
        recommendations = []
        
        required_headers = {
            "X-Content-Type-Options": "nosniff",
            "X-Frame-Options": ["DENY", "SAMEORIGIN"],
            "X-XSS-Protection": "1; mode=block",
            "Strict-Transport-Security": "max-age",
            "Content-Security-Policy": "default-src"
        }
        
        try:
            async with session.get(f"{base_url}/health") as response:
                headers = response.headers
                
                for header, expected in required_headers.items():
                    if header not in headers:
                        missing_headers.append(header)
                        
                        vulnerability = Vulnerability(
                            id=f"missing_header_{header.lower().replace('-', '_')}",
                            severity="medium",
                            category="api_security",
                            title=f"Missing security header: {header}",
                            description=f"The {header} security header is not set",
                            remediation=f"Add {header} header to API responses",
                            references=["https://owasp.org/www-project-secure-headers/"]
                        )
                        vulnerabilities.append(vulnerability)
                
                if missing_headers:
                    recommendations.append("Implement comprehensive security headers")
        
        except Exception as e:
            self.logger.error(f"Security headers check failed: {e}")
        
        return {
            "vulnerabilities": vulnerabilities,
            "missing_headers": missing_headers,
            "recommendations": recommendations
        }
    
    async def _check_api_endpoints(self, session: aiohttp.ClientSession, base_url: str) -> List[Vulnerability]:
        """Check API endpoints for common vulnerabilities."""
        vulnerabilities = []
        
        # Test endpoints for security issues
        test_cases = [
            {
                "endpoint": "/health",
                "method": "GET",
                "description": "Health check endpoint"
            },
            {
                "endpoint": "/chat",
                "method": "POST",
                "description": "Chat endpoint",
                "payload": {"message": "test"}
            }
        ]
        
        for test in test_cases:
            try:
                if test["method"] == "GET":
                    async with session.get(f"{base_url}{test['endpoint']}") as response:
                        await self._analyze_response_security(response, test, vulnerabilities)
                elif test["method"] == "POST":
                    payload = test.get("payload", {})
                    async with session.post(f"{base_url}{test['endpoint']}", json=payload) as response:
                        await self._analyze_response_security(response, test, vulnerabilities)
            
            except Exception as e:
                self.logger.error(f"API endpoint test failed for {test['endpoint']}: {e}")
        
        return vulnerabilities
    
    async def _analyze_response_security(self, response, test_case: Dict, vulnerabilities: List[Vulnerability]):
        """Analyze API response for security issues."""
        # Check for information disclosure
        response_text = await response.text()
        
        # Check for stack traces or error details
        error_patterns = [
            r"Traceback",
            r"Exception in thread",
            r"SQLException",
            r"ORA-\d+",
            r"MySQL Error",
            r"PostgreSQL Error"
        ]
        
        import re
        for pattern in error_patterns:
            if re.search(pattern, response_text, re.IGNORECASE):
                vulnerability = Vulnerability(
                    id=f"info_disclosure_{test_case['endpoint'].replace('/', '_')}",
                    severity="medium",
                    category="information_disclosure",
                    title=f"Information disclosure in {test_case['endpoint']}",
                    description="API endpoint may expose sensitive error information",
                    remediation="Implement proper error handling and sanitization",
                    references=["https://owasp.org/www-community/Improper_Error_Handling"]
                )
                vulnerabilities.append(vulnerability)
                break
    
    async def _run_config_scan(self) -> Tuple[List[Vulnerability], Dict[str, bool], List[str]]:
        """Scan configuration files for security issues."""
        vulnerabilities = []
        compliance = {"configuration_security": True}
        recommendations = []
        
        # Check for sensitive data in config files
        config_files = [
            ".env",
            "docker-compose.yml",
            "pyproject.toml"
        ]
        
        sensitive_patterns = [
            (r"password\s*=\s*['\"]?[^'\"\\s]+", "hardcoded_password"),
            (r"secret\s*=\s*['\"]?[^'\"\\s]+", "hardcoded_secret"),
            (r"api_key\s*=\s*['\"]?[^'\"\\s]+", "hardcoded_api_key"),
            (r"token\s*=\s*['\"]?[^'\"\\s]+", "hardcoded_token")
        ]
        
        for config_file in config_files:
            file_path = Path(config_file)
            if file_path.exists():
                try:
                    content = file_path.read_text()
                    
                    for pattern, vuln_type in sensitive_patterns:
                        import re
                        matches = re.finditer(pattern, content, re.IGNORECASE)
                        
                        for match in matches:
                            line_number = content[:match.start()].count('\n') + 1
                            
                            vulnerability = Vulnerability(
                                id=f"config_{vuln_type}_{config_file}_{line_number}",
                                severity="high",
                                category="configuration",
                                title=f"Hardcoded secret in {config_file}",
                                description=f"Sensitive information found in configuration file",
                                file_path=config_file,
                                line_number=line_number,
                                remediation="Use environment variables or secure secret management",
                                references=["https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password"]
                            )
                            vulnerabilities.append(vulnerability)
                
                except Exception as e:
                    self.logger.error(f"Error scanning {config_file}: {e}")
        
        if vulnerabilities:
            compliance["configuration_security"] = False
            recommendations.append("Remove hardcoded secrets from configuration files")
        
        return vulnerabilities, compliance, recommendations
    
    def _generate_summary(self, vulnerabilities: List[Vulnerability]) -> Dict[str, int]:
        """Generate vulnerability summary statistics."""
        summary = {
            "total": len(vulnerabilities),
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "by_category": {}
        }
        
        for vuln in vulnerabilities:
            # Count by severity
            if vuln.severity in summary:
                summary[vuln.severity] += 1
            
            # Count by category
            if vuln.category not in summary["by_category"]:
                summary["by_category"][vuln.category] = 0
            summary["by_category"][vuln.category] += 1
        
        return summary
    
    def export_results(self, scan_result: ScanResult, format: str = "json") -> str:
        """Export scan results to various formats."""
        if format == "json":
            return json.dumps(asdict(scan_result), indent=2, default=str)
        
        elif format == "yaml":
            return yaml.dump(asdict(scan_result), default_flow_style=False)
        
        elif format == "html":
            return self._generate_html_report(scan_result)
        
        else:
            raise ValueError(f"Unsupported format: {format}")
    
    def _generate_html_report(self, scan_result: ScanResult) -> str:
        """Generate HTML security report."""
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>FisioRAG Security Scan Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background-color: #f5f5f5; padding: 20px; border-radius: 5px; }}
                .summary {{ display: flex; gap: 20px; margin: 20px 0; }}
                .metric {{ background-color: #e9ecef; padding: 15px; border-radius: 5px; text-align: center; }}
                .critical {{ background-color: #dc3545; color: white; }}
                .high {{ background-color: #fd7e14; color: white; }}
                .medium {{ background-color: #ffc107; }}
                .low {{ background-color: #28a745; color: white; }}
                .vulnerability {{ border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }}
                .recommendations {{ background-color: #d1ecf1; padding: 15px; border-radius: 5px; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>FisioRAG Security Scan Report</h1>
                <p><strong>Scan ID:</strong> {scan_result.scan_id}</p>
                <p><strong>Timestamp:</strong> {scan_result.timestamp}</p>
                <p><strong>Duration:</strong> {scan_result.duration_seconds:.2f} seconds</p>
            </div>
            
            <div class="summary">
                <div class="metric critical">
                    <h3>{scan_result.summary.get('critical', 0)}</h3>
                    <p>Critical</p>
                </div>
                <div class="metric high">
                    <h3>{scan_result.summary.get('high', 0)}</h3>
                    <p>High</p>
                </div>
                <div class="metric medium">
                    <h3>{scan_result.summary.get('medium', 0)}</h3>
                    <p>Medium</p>
                </div>
                <div class="metric low">
                    <h3>{scan_result.summary.get('low', 0)}</h3>
                    <p>Low</p>
                </div>
            </div>
            
            <h2>Vulnerabilities</h2>
        """
        
        for vuln in scan_result.vulnerabilities:
            html += f"""
            <div class="vulnerability">
                <h3>{vuln.title}</h3>
                <p><strong>Severity:</strong> <span class="{vuln.severity}">{vuln.severity.upper()}</span></p>
                <p><strong>Category:</strong> {vuln.category}</p>
                <p><strong>Description:</strong> {vuln.description}</p>
                {f'<p><strong>File:</strong> {vuln.file_path}:{vuln.line_number}</p>' if vuln.file_path else ''}
                {f'<p><strong>CVE:</strong> {vuln.cve_id}</p>' if vuln.cve_id else ''}
                {f'<p><strong>Remediation:</strong> {vuln.remediation}</p>' if vuln.remediation else ''}
            </div>
            """
        
        if scan_result.recommendations:
            html += f"""
            <div class="recommendations">
                <h2>Recommendations</h2>
                <ul>
                    {''.join(f'<li>{rec}</li>' for rec in scan_result.recommendations)}
                </ul>
            </div>
            """
        
        html += """
        </body>
        </html>
        """
        
        return html
    
    async def continuous_monitoring(self, interval_hours: int = 24):
        """Run continuous security monitoring."""
        while True:
            try:
                scan_result = await self.run_comprehensive_scan()
                
                # Alert on critical/high vulnerabilities
                critical_high = [v for v in scan_result.vulnerabilities 
                               if v.severity in ["critical", "high"]]
                
                if critical_high:
                    self.logger.critical(f"Security Alert: {len(critical_high)} critical/high vulnerabilities found")
                
                # Wait for next scan
                await asyncio.sleep(interval_hours * 3600)
                
            except Exception as e:
                self.logger.error(f"Continuous monitoring error: {e}")
                await asyncio.sleep(3600)  # Wait 1 hour on error


# Main execution
async def main():
    """Run security vulnerability scan."""
    scanner = VulnerabilityScanner()
    
    print("🔒 Starting FisioRAG Security Vulnerability Scan...")
    scan_result = await scanner.run_comprehensive_scan()
    
    # Print summary
    print(f"\n📊 Scan Results Summary:")
    print(f"   Total Vulnerabilities: {scan_result.summary['total']}")
    print(f"   Critical: {scan_result.summary.get('critical', 0)}")
    print(f"   High: {scan_result.summary.get('high', 0)}")
    print(f"   Medium: {scan_result.summary.get('medium', 0)}")
    print(f"   Low: {scan_result.summary.get('low', 0)}")
    
    # Save results
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # JSON report
    json_report = scanner.export_results(scan_result, "json")
    with open(f"security/reports/vulnerability_scan_{timestamp}.json", "w") as f:
        f.write(json_report)
    
    # HTML report
    html_report = scanner.export_results(scan_result, "html")
    with open(f"security/reports/vulnerability_scan_{timestamp}.html", "w") as f:
        f.write(html_report)
    
    print(f"\n📄 Reports saved:")
    print(f"   JSON: security/reports/vulnerability_scan_{timestamp}.json")
    print(f"   HTML: security/reports/vulnerability_scan_{timestamp}.html")
    
    if scan_result.recommendations:
        print(f"\n💡 Recommendations:")
        for rec in scan_result.recommendations:
            print(f"   • {rec}")
    
    return scan_result


if __name__ == "__main__":
    asyncio.run(main())
